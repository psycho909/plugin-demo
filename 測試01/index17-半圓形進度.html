<!DOCTYPE html>
<html lang="zh-Hant">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />
		<title>Gauge — 動態 update R / stroke / color</title>
		<style>
			body {
				background: #1e1e1e;
				color: #fff;
				font-family: Arial, Helvetica, sans-serif;
				display: flex;
				flex-direction: column;
				align-items: center;
				gap: 26px;
				padding: 40px;
			}
			svg {
				overflow: visible;
			}
			text {
				dominant-baseline: middle;
				text-anchor: middle;
				font-weight: 700;
				fill: #fff;
			}
			.row {
				display: flex;
				gap: 32px;
				flex-wrap: wrap;
				justify-content: center;
			}
			button {
				margin: 6px 8px;
				padding: 6px 14px;
				background: #00d4aa;
				border: 0;
				border-radius: 4px;
				color: #fff;
				cursor: pointer;
			}
			button:hover {
				background: #00b89a;
			}
		</style>
	</head>
	<body>
		<h2>動態調整 Gauge</h2>

		<div class="row">
			<svg id="gauge"></svg>
		</div>

		<div>
			<button onclick="gauge.update({R:140,stroke:20,color:'#000'})">R=140 / stroke=20 / 粉紅</button>
			<button onclick="gauge.update({R:80,stroke:12,gradient:[{offset:'0%',color:'#00ffe5'},{offset:'100%',color:'#0061ff'}]})">回到小尺寸 + 漸層</button>
			<button onclick="gauge.animateTo(Math.random()*100,1.2)">隨機值 (動畫)</button>
		</div>
		<script src="https://tw.hicdn.beanfun.com/plugins/gsap/3.11.5/gsap.min.js"></script>
		<!-- Chart.js v2.9.3 -->
		<script src="https://cdn.jsdelivr.net/npm/chart.js@2.9.3/dist/Chart.min.js"></script>
		<!-- chartjs-plugin-datalabels -->
		<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@0.7.0/dist/chartjs-plugin-datalabels.min.js"></script>
		<script>
			/* ---------- Gauge Class ---------- */
			let gid = 0; // 漸層 id
			class Gauge {
				constructor(svg, opt = {}) {
					this.svg = svg;
					this._defaults();
					this.update(opt);
				}
				/* ===== 公開 API ===== */
				setValue(v) {
					this._update(Math.max(0, Math.min(100, v)));
				}
				animateTo(v, d = 1) {
					this.tween?.kill();
					this.tween = gsap.to({ p: this.cur }, { p: v, duration: d, ease: "power1.inOut", onUpdate: () => this._update(this.tween.targets()[0].p) });
				}
				/** 動態更新設定並重建 */
				update(opts) {
					// 合併新設定，保留當前 value
					const keepVal = this.cur ?? this.cfg?.value ?? 0;
					this.cfg = { ...this.def, ...(this.cfg || {}), ...opts };
					this.svg.innerHTML = ""; // 清空舊畫面
					this._build(); // 重新繪製
					this.setValue(keepVal); // 還原進度
				}
				/* ===== 私有 ===== */
				_defaults() {
					this.def = {
						R: 80,
						stroke: 12,
						color: "#00d4aa",
						gradient: null,
						value: 0,
						bgExtra: 1.2,
						gap: 0.45,
						arrowScale: 0.23,
						valueDy: -0.15
					};
				}
				_build() {
					const C = this.cfg,
						{ R, stroke, bgExtra, gradient, color, arrowScale, valueDy } = C;
					const WH = R * 2;
					this.svg.setAttribute("width", WH);
					this.svg.setAttribute("height", R + stroke);
					this.svg.setAttribute("viewBox", `0 0 ${WH} ${R + stroke}`);
					const Cx = R,
						Cy = R;
					this.Cx = Cx;
					this.Cy = Cy;

					/* defs & gradient */
					let paint = color;
					if (gradient) {
						const id = `grad_${++gid}`;
						const defs = this._elm("defs");
						const lg = this._elm("linearGradient", { id, x1: "0%", y1: "0%", x2: "100%", y2: "0%" }, defs);
						gradient.forEach((s) => this._elm("stop", { offset: s.offset, "stop-color": s.color }, lg));
						paint = `url(#${id})`;
						this.arrowColor = gradient.at(-1).color;
					} else this.arrowColor = color;

					const arc = `M 0 ${Cy} A ${R} ${R} 0 0 1 ${R * 2} ${Cy}`;
					this._path({ d: arc, stroke: "#fff", "stroke-width": stroke * (1 + bgExtra), "stroke-linecap": "butt", fill: "none" });
					this.bar = this._path({ d: arc, stroke: paint, "stroke-width": stroke, "stroke-linecap": "butt", fill: "none" });

					this.gArrow = this._elm("g");
					const ah = R * arrowScale;
					this._elm("polygon", { points: `-${ah * 0.45},0 ${ah * 0.45},0 0,-${ah}`, fill: this.arrowColor }, this.gArrow);

					this.txt = this._elm("text", { x: Cx, y: Cy + valueDy * R, "font-size": R * 0.45 });
				}
				_update(p) {
					const { R, stroke, gap } = this.cfg,
						FULL = Math.PI * R;
					this.bar.setAttribute("stroke-dasharray", `${(p / 100) * FULL} ${FULL - (p / 100) * FULL}`);
					this.txt.textContent = Math.round(p) + "%";
					const θ = Math.PI - (p / 100) * Math.PI,
						ρ = R + stroke / 2 + R * gap,
						x = this.Cx + ρ * Math.cos(θ),
						y = this.Cy - ρ * Math.sin(θ),
						deg = 270 - (θ * 180) / Math.PI;
					this.gArrow.setAttribute("transform", `translate(${x} ${y}) rotate(${deg})`);
					this.cur = p;
				}
				_elm(tag, attr = {}, parent = this.svg) {
					const e = document.createElementNS("http://www.w3.org/2000/svg", tag);
					for (const k in attr) e.setAttribute(k, attr[k]);
					parent.appendChild(e);
					return e;
				}
				_path(a, p) {
					return this._elm("path", a, p);
				}
			}

			/* ---------- 建立實例 ---------- */
			const gauge = new Gauge(document.getElementById("gauge"), {
				R: 100,
				stroke: 14,
				value: 35,
				gradient: [
					{ offset: "0%", color: "#00ffe5" },
					{ offset: "100%", color: "#0061ff" }
				]
			});
		</script>
	</body>
</html>
