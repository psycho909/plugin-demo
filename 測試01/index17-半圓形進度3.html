<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Canvas Gauge</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
		<style>
			body {
				font-family: Arial, sans-serif;
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 40px;
				background: #f0f0f0;
			}
			.container {
				display: flex;
				gap: 40px;
				margin-bottom: 40px;
			}
			.gauge-wrapper {
				background: white;
				padding: 20px;
				border-radius: 10px;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
			}
			h3 {
				margin: 0 0 20px 0;
				text-align: center;
				color: #333;
			}
			.controls {
				display: flex;
				gap: 10px;
				margin-top: 20px;
			}
			button {
				padding: 10px 20px;
				background: #007bff;
				color: white;
				border: none;
				border-radius: 5px;
				cursor: pointer;
			}
			button:hover {
				background: #0056b3;
			}
			input {
				padding: 8px;
				border: 1px solid #ddd;
				border-radius: 4px;
				width: 80px;
			}
		</style>
	</head>
	<body>
		<h1>Canvas Gauge Demo</h1>

		<div class="container">
			<div class="gauge-wrapper">
				<h3>Simple Gauge</h3>
				<canvas id="gauge1"></canvas>
			</div>

			<div class="gauge-wrapper">
				<h3>Gradient Gauge</h3>
				<canvas id="gauge2"></canvas>
			</div>

			<div class="gauge-wrapper">
				<h3>Custom Style</h3>
				<canvas id="gauge3"></canvas>
			</div>
		</div>

		<div class="controls">
			<button onclick="randomValue()">Random Value</button>
			<button onclick="animateAll()">Animate to 75%</button>
			<input type="number" id="valueInput" placeholder="Value" min="0" max="100" />
			<button onclick="setCustomValue()">Set Value</button>
			<button onclick="cloneGauge()">Clone Gauge 1</button>
		</div>

		<div id="box" style="margin-top: 30px; padding: 20px; background: #fff; border-radius: 10px; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1)">
			<h3>Cloned Gauges Container</h3>
			<div style="display: flex; gap: 20px; flex-wrap: wrap; margin-top: 20px"></div>
		</div>

		<script>
			class Gauge {
				static _gid = 0;

				constructor(canvas, opt = {}) {
					this.canvas = canvas;
					this.ctx = canvas.getContext("2d");
					this._defaults();
					this.cfg = { ...this.def, ...opt };
					this._build();
					this._update(this.cfg.value);

					// Set up animation frame
					this.animating = false;
				}

				setValue(v) {
					this._update(Math.max(0, Math.min(100, v)));
				}

				animateTo(v, d = 1) {
					this.tween?.kill();
					this.tween = gsap.to(
						{ p: this.cur },
						{
							p: v,
							duration: d,
							ease: "power1.inOut",
							onUpdate: () => {
								this._update(this.tween.targets()[0].p);
								this._render();
							}
						}
					);
				}

				update(opts) {
					const keep = this.cur;
					this.cfg = { ...this.cfg, ...opts };
					this._build();
					this._update(keep);
					this._render();
				}

				clone(targetCanvas) {
					// Create new gauge instance with same configuration
					const newGauge = new Gauge(targetCanvas, { ...this.cfg });
					newGauge.setValue(this.cur);
					return newGauge;
				}

				copyCanvasContent(targetCanvas) {
					// Direct copy of canvas pixel content
					targetCanvas.width = this.canvas.width;
					targetCanvas.height = this.canvas.height;
					const targetCtx = targetCanvas.getContext("2d");
					targetCtx.drawImage(this.canvas, 0, 0);
				}

				_defaults() {
					this.def = {
						R: 80,
						stroke: 12,
						color: "#00d4aa",
						gradient: null,
						value: 0,
						bgExtra: 1.2,
						gap: 0.35, // Reduced gap slightly
						arrowScale: 0.2, // Reduced arrow scale slightly
						valueDy: -0.15,
						bgColor: "#e0e0e0",
						textColor: "#333",
						fontFamily: "Arial, sans-serif"
					};
				}

				_build() {
					const { R, stroke, gap, arrowScale, bgExtra } = this.cfg;

					// Calculate padding needed for arrow and stroke
					const arrowHeight = R * arrowScale;
					const arrowRadius = R + stroke / 2 + R * gap + arrowHeight;
					const strokePadding = (stroke * (1 + bgExtra)) / 2;

					// Add padding to ensure nothing gets clipped
					const padding = Math.max(arrowHeight, strokePadding) + 10;

					const WH = R * 2 + padding * 2;
					const H = R + padding * 2;

					this.canvas.width = WH;
					this.canvas.height = H;

					this.Cx = WH / 2;
					this.Cy = R + padding;

					// Setup gradient if specified
					if (this.cfg.gradient) {
						const gradient = this.ctx.createLinearGradient(0, this.Cy, WH, this.Cy);
						this.cfg.gradient.forEach((stop) => {
							gradient.addColorStop(parseFloat(stop.offset.replace("%", "")) / 100, stop.color);
						});
						this.strokePaint = gradient;
						this.arrowColor = this.cfg.gradient[this.cfg.gradient.length - 1].color;
					} else {
						this.strokePaint = this.cfg.color;
						this.arrowColor = this.cfg.color;
					}
				}

				_update(p) {
					this.cur = p;
					this._render();
				}

				_render() {
					const { R, stroke, bgExtra, gap, arrowScale, valueDy, bgColor, textColor, fontFamily } = this.cfg;
					const ctx = this.ctx;

					// Clear canvas
					ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

					// Draw background arc
					ctx.beginPath();
					ctx.arc(this.Cx, this.Cy, R, Math.PI, 2 * Math.PI, false);
					ctx.strokeStyle = bgColor;
					ctx.lineWidth = stroke * (1 + bgExtra);
					ctx.lineCap = "butt";
					ctx.stroke();

					// Draw progress arc
					const startAngle = Math.PI;
					const endAngle = Math.PI + (this.cur / 100) * Math.PI;

					ctx.beginPath();
					ctx.arc(this.Cx, this.Cy, R, startAngle, endAngle, false);

					if (this.cfg.gradient) {
						ctx.strokeStyle = this.strokePaint;
					} else {
						ctx.strokeStyle = this.cfg.color;
					}

					ctx.lineWidth = stroke;
					ctx.lineCap = "butt";
					ctx.stroke();

					// Draw arrow
					const θ = Math.PI - (this.cur / 100) * Math.PI;
					const ρ = R + stroke / 2 + R * gap;
					const x = this.Cx + ρ * Math.cos(θ);
					const y = this.Cy - ρ * Math.sin(θ);
					const deg = 270 - (θ * 180) / Math.PI;

					ctx.save();
					ctx.translate(x, y);
					ctx.rotate((deg * Math.PI) / 180);

					const ah = R * arrowScale;
					ctx.beginPath();
					ctx.moveTo(-ah * 0.45, 0);
					ctx.lineTo(ah * 0.45, 0);
					ctx.lineTo(0, -ah);
					ctx.closePath();
					ctx.fillStyle = this.arrowColor;
					ctx.fill();

					// Add arrow outline for better visibility
					ctx.strokeStyle = this.arrowColor;
					ctx.lineWidth = 1;
					ctx.stroke();

					ctx.restore();

					// Draw text
					ctx.fillStyle = textColor;
					ctx.font = `${R * 0.45}px ${fontFamily}`;
					ctx.textAlign = "center";
					ctx.textBaseline = "middle";
					ctx.fillText(Math.round(this.cur) + "%", this.Cx, this.Cy + valueDy * R);
				}
			}

			// Create gauges
			const gauge1 = new Gauge(document.getElementById("gauge1"), {
				value: 65,
				color: "#00d4aa"
			});

			const gauge2 = new Gauge(document.getElementById("gauge2"), {
				value: 42,
				gradient: [
					{ offset: "0%", color: "#ff6b6b" },
					{ offset: "50%", color: "#feca57" },
					{ offset: "100%", color: "#48dbfb" }
				]
			});

			const gauge3 = new Gauge(document.getElementById("gauge3"), {
				value: 85,
				color: "#5f27cd",
				R: 70,
				stroke: 16,
				bgExtra: 1.3,
				gap: 0.35,
				arrowScale: 0.22,
				bgColor: "#dfe6e9",
				textColor: "#2d3436"
			});

			// Control functions
			function randomValue() {
				const value = Math.random() * 100;
				gauge1.animateTo(value);
				gauge2.animateTo(value);
				gauge3.animateTo(value);
			}

			function animateAll() {
				gauge1.animateTo(75, 1.5);
				gauge2.animateTo(75, 1.5);
				gauge3.animateTo(75, 1.5);
			}

			function setCustomValue() {
				const value = parseFloat(document.getElementById("valueInput").value);
				if (!isNaN(value)) {
					gauge1.animateTo(value);
					gauge2.animateTo(value);
					gauge3.animateTo(value);
				}
			}

			// Clone function
			function cloneGauge() {
				// Method 1: Clone with new Gauge instance (recommended)
				const newCanvas = document.createElement("canvas");
				const wrapper = document.createElement("div");
				wrapper.style.display = "inline-block";
				wrapper.style.padding = "10px";
				wrapper.style.background = "#f9f9f9";
				wrapper.style.borderRadius = "8px";
				wrapper.appendChild(newCanvas);

				const container = document.querySelector("#box > div");
				container.appendChild(wrapper);

				// Create new gauge with same configuration
				const clonedGauge = gauge1.clone(newCanvas);

				// Optional: animate the cloned gauge
				setTimeout(() => {
					clonedGauge.animateTo(Math.random() * 100, 1);
				}, 100);
			}

			// Alternative method: Direct canvas copy (static image)
			function cloneCanvasAsImage() {
				const sourceCanvas = document.getElementById("gauge1");
				const newCanvas = document.createElement("canvas");

				// Copy the canvas content
				gauge1.copyCanvasContent(newCanvas);

				const wrapper = document.createElement("div");
				wrapper.style.display = "inline-block";
				wrapper.style.padding = "10px";
				wrapper.style.background = "#f9f9f9";
				wrapper.style.borderRadius = "8px";
				wrapper.appendChild(newCanvas);

				const container = document.querySelector("#box > div");
				container.appendChild(wrapper);
			}

			// Store gauge instances globally for easy access
			window.gauges = [gauge1, gauge2, gauge3];

			// Initial animation
			setTimeout(() => {
				gauge1.animateTo(65, 2);
				gauge2.animateTo(42, 2);
				gauge3.animateTo(85, 2);
			}, 500);
		</script>
	</body>
</html>
